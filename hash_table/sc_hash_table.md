# 散列表之分离链接法 (Separate Chaining)

> **参考书籍**：《数据结构与算法分析：C语言描述》 (Mark Allen Weiss)

## 1. 核心概念

**分离链接法 (Separate Chaining)** 是解决 **散列冲突 (Collision)** 最常用、最直观的方法之一。

### 什么是冲突？

当两个不同的关键字 (Key) 通过散列函数计算出相同的散列值 (Hash Value) 时，即 

$$Hash(k_1) = Hash(k_2)$$

，就发生了冲突。

### 解决方案

分离链接法的做法是将 **散列表 (Hash Table)** 看作是一个 **链表的数组**。

- **数组**：提供 $O(1)$ 的快速索引。
- **链表**：用于存储所有散列值相同的元素。

> **直观理解**：想象你有 $M$ 个桶（数组），如果有多个球（数据）被扔进了同一个桶里，你就把这些球用绳子串起来（链表）。

------

## 2. 数据结构定义

在具体实现中，我们需要定义 **节点 (Node)** 和 **散列表 (Hash Table)** 本身。

- **节点 (Node)**：通常包含数据元素 (`Element`) 和指向下一个节点的指针 (`Next`)。
- **散列表 (Hash Table)**：通常包含表的大小 (`TableSize`) 和一个指针数组，该数组中的每个指针都指向一个链表的表头。

> **🌟 最佳实践**：为了保证散列分布均匀，表的大小 (`TableSize`) 最好是一个 **素数**。

------

## 3. 核心操作逻辑

### 3.1 初始化 (Initialization)

初始化通常包含以下步骤：

1. 为散列表结构分配内存。
2. 为数组中的每一个 **槽位 (Slot)** 分配一个 **链表表头 (Header)**。

**关于表头 (Header) 的权衡**：

- **优点**：简化逻辑，尤其是插入和删除操作（不需要处理第一个节点的特殊情况）。
- **缺点**：浪费空间。如果表很大但数据很少，分配大量的空表头是不划算的。

### 3.2 查找 (Find)

查找操作的逻辑非常直观：

1. **计算 Hash 值**：根据 Key 计算出对应的数组索引。
2. **定位链表**：找到该索引对应的链表。
3. **遍历链表**：从表头开始向后遍历，逐个比对 Key，直到找到或者遍历结束。

### 3.3 插入 (Insert)

书中的标准插入策略是：先检查是否存在，如果不存在，则插入到链表的 **前端 (Front)**。

**步骤**：

1. 执行查找逻辑。
2. 如果找到该 Key，则什么也不做（或更新值）。
3. 如果没找到，创建一个新节点。
4. 将新节点插入到对应链表的头部（通常位于表头节点之后）。

> **💡 为什么插在前端？**
>
> - 因为新插入的元素被再次访问的概率通常较高（**局部性原理**）。
> - 在单链表中，头部插入的操作是常数时间 $O(1)$，效率最高。

> ⚡ 优化建议
>
> 标准的插入逻辑通常会先调用“查找”函数，然后再计算一次 Hash 值进行“插入”。在高性能场景下，应该合并这两个步骤，避免重复计算 Hash 值。

------

## 4. 性能分析 (Performance Analysis)

分离链接法的性能主要取决于 **装填因子 (Load Factor)**。

### 4.1 定义

- $N$：散列表中的元素个数。

- $M$：散列表的大小 (`TableSize`)。

- **装填因子 $\lambda$**：

    $$\lambda = N / M$$

**$\lambda$ 代表了链表的平均长度。**

### 4.2 复杂度

假设散列函数分布均匀：

- **计算 Hash 值**：$O(1)$。
- **不成功的查找 (Unsuccessful Search)**：
    - 需要遍历完整个链表。
    - 平均开销：$O(\lambda)$。
- **成功的查找 (Successful Search)**：
    - 平均需要遍历链表的一半。
    - 平均开销：$O(1 + \lambda / 2)$。

### 4.3 结论

表的大小 $M$ 并不直接决定速度，关键是 $\lambda$。

- **一般法则**：对于分离链接法，我们希望 $\lambda \approx 1$。
- 也就是说，如果你有 $N$ 个元素，表的大小 $M$ 应该大致等于 $N$。此时，查找操作就是常数时间 $O(1)$。

------

## 5. 优缺点总结

| **特性** | **描述**                                                     |
| -------- | ------------------------------------------------------------ |
| **优点** | 1. **实现简单**：标准的链表操作。 2. **对 $\lambda$ 不敏感**：即使 $\lambda > 1$（元素多于槽位），性能下降也是线性的，不会像开放定址法那样急剧恶化。 3. **易于删除**：标准的链表删除操作即可。 |
| **缺点** | 1. **指针开销**：需要额外的空间存储 `Next` 指针。 2. **内存分配**：频繁的动态内存分配会带来一定的时间开销。 3. **缓存性能**：链表节点在内存中是分散的，可能导致 CPU 缓存命中率 (Cache Hit) 不如数组高。 |

------

## 6. 关键细节备忘 (Cheat Sheet)

- **表大小选素数**：为了 Hash 分布均匀。
- **表头 (Header) 的使用**：如果不想处理删除首节点的特殊逻辑，建议使用表头；如果内存极度紧张且不需删除，可不用表头。
- **避免重复计算**：在执行插入操作时，尽量在一次 Hash 计算中完成查找和插入，避免重复调用 Hash 函数。
- **字符串比较**：如果是字符串 Key，记得比较字符串的内容（值），而不是比较它们的内存地址（使用 `strcmp`）。
